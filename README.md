# Airframe  [![Gitter Chat][gitter-badge]][gitter-link] [![Build Status](https://travis-ci.org/wvlet/airframe.svg?branch=master)](https://travis-ci.org/wvlet/airframe) [![Latest version](https://index.scala-lang.org/wvlet/airframe/airframe/latest.svg?color=orange)](https://index.scala-lang.org/wvlet/airframe) [![codecov](https://codecov.io/gh/wvlet/airframe/branch/master/graph/badge.svg)](https://codecov.io/gh/wvlet/airframe) [![Scala.js](https://www.scala-js.org/assets/badges/scalajs-0.6.15.svg)](https://www.scala-js.org)

[circleci-badge]: https://circleci.com/gh/wvlet/airframe.svg?style=svg
[circleci-link]: https://circleci.com/gh/wvlet/airframe
[gitter-badge]: https://badges.gitter.im/Join%20Chat.svg
[gitter-link]: https://gitter.im/wvlet/wvlet?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge
[coverall-badge]: https://coveralls.io/repos/github/wvlet/airframe/badge.svg?branch=master
[coverall-link]: https://coveralls.io/github/wvlet/airframe?branch=master

Airframe is a dependency injection (DI) library tailored to Scala. While Google's [Guice](https://github.com/google/guice) is designed for injecting Java objects (e.g., using constructors or providers), Airframe redesigned it for Scala traits so that we can mix-in traits that have several object dependencies.

Airframe can be used in three steps:
- ***Bind***: Inject necessary classes with `bind[X]`:
```scala
import wvlet.airframe._

trait App {
  val x = bind[X]
  val y = bind[Y]
  val z = bind[Z]
  // Do something with X, Y, and Z
}
```
- ***Design***: Describe how to provide object instances:
```scala
val design : Design =
   newDesign
     .bind[X].toInstance(new X)  // Bind type X to a concrete instance
     .bind[Y].toSingleton        // Bind type Y to a singleton object
     .bind[Z].to[ZImpl]          // Bind type Z to an instance of ZImpl

// Note that *Design* is *immutable*, so you can safely reuse and extend it by adding more bindings.     
```

- ***Build***: Create a concrete instance:
```scala
val session = design.newSession
val app : App = session.build[App]
```

Airframe builds an instance of `App` based on the binding rules specified in the *Design* object.
`Session` manages the lifecycle of objects generated by Airframe. For example, singleton objects that are instantiated within a Session will be discarded when `Session.shutdown` is called.

The major advantages of Airframe include:
- Simple usage. Just `import wvlet.airframe._` and do the above three steps to enjoy DI in Scala!
- *Design* remembers how to build complex objects on your behalf.
  - For example, you can avoid code duplications in your test and production codes. Compare writing `new App(new X, new Y(...), new Z(...), ...)` every time and just calling `session.build[App]`.
  - When writing application codes, you only need to care about how to ***use*** objects, rather than how to ***provide*** them. *Design* already knows how to provide objects to your class.
- You can enjoy the flexibility of Scala traits and dependency injection (DI) at the same time.
  - Mixing traits is far easier than calling object constructors. This is because traits can be combined in an arbitrary order. So you no longer need to remember the order of the constructor arguments.
- Scala macro based binding generation.
- Scala 2.11, 2.12, Scala.js support.

# Usage

[![Maven Central](https://maven-badges.herokuapp.com/maven-central/org.wvlet/airframe_2.11/badge.svg)](https://maven-badges.herokuapp.com/maven-central/org.wvlet/airframe_2.11)
- [Release Notes](https://github.com/wvlet/airframe/blob/master/RELEASE_NOTES.md)

**build.sbt**
```
libraryDependencies += "org.wvlet" %% "airframe" % "(version)"

# For Scala.js (supported since airframe 0.12)
libraryDependencies += "org.wvlet" %%% "airframe" % "(version)"
```

## Binding Examples

This example shows all binding types available in Airframe:

```scala
import wvlet.airframe._
import BindingExample._

trait BindingExample {
  val a = bind[A]  // Inject A
  val b = bind[B]  // Inject B

  val s = bindSingleton[S] // Inject S as a singleton

  val p0: P = bind { P() } // Inject P using the provider function (closure)
  val p1: P = bind { d1:D1 => P(d1) } // Inject D1 to create P
  val p2: P = bind { (d1:D1, d2:D2) => P(d1, d2) } // Inject D1 and D2 to create P
  val p3: P = bind { (d1:D1, d2:D2, d3:D3) => P(d1, d2, d3) } // Inject D1, D2 and D3

  val pd: P = bind { provider _ } // Inject D1, D2 and D3 to call a provider function
  val ps: P = bindSingleton { provider _ } // Create a singleton using a provider
}

object BindingExample {
  case class P(d1:D1 = D1(), d2:D2 = D2(), d3:D3 = D3())
  def provider(d1:D1, d2:D2, d3:D3) : P = P(d1, d2, d3)
}
```

## Design Examples

To configure actual bindings, define object bindings using **design**:

```scala
import wvlet.airframe._
// If you define multiple bindings to the same type, the last one will be used.
val design : Design =
  newDesign                      // Create an empty design
  .bind[A].to[AImpl]             // Bind a concrete class AImpl to A
  .bind[B].toInstance(new B(1))  // Bind a concrete instance to B (This instance will be a singleton)
  .bind[S].toSingleton           // S will be a singleton within the session
  .bind[ES].toEagerSingleton     // ES will be initialized as a singleton at session start time
  .bind[D1].toInstance(D1(1))    // Bind D1 to a concrete instance D1(1)
  .bind[D2].toInstance(D2(2))    // Bind D2 to a concrete instance D2(2)
  .bind[D3].toInstance(D3(3))    // Bind D3 to a cocreete instance D3(3)
  .bind[P].toProvider{ d1:D1 => P(d1) } // Create P by resolveing D1 from the design to create P
  .bind[P].toProvider{ (d1:D1, d2:D2) => P(d1, d2) } // Resolve D1 and D2
  .bind[P].toProvider{ provider _ }  // Use a function as a provider. D1, D2 and D3 will be resolved from the design
  .bind[P].toSingletonProvider{ d1:D1 => P(d1) } // Create a singleton using the provider function
  .bind[P].toEagerSingletonProvider{ d1:D1 => P(d1) } // Create an eager singleton using the provider function

// Start a session
val session = desing.newSession
try {
  session.start
  val p = session.build[P]
}
finally {
   session.shutdown
}
```

## Life Cycle Management

Server-side applications often require object initializtaion, server start, and shutdown hooks.
Airframe has a built-in object life cycle manager to implement these hooks:

```scala
// Your server application
trait Server {
  def init() {}
  def start() {}
  def stop() {}
}

// When binding an object, you can define life cycle hooks to the injected object:
trait MyServerService {
  val service = bind[Server].withLifeCycle(
    init = { _.init },    // Called when the object is initialized (called only once for singleton)
    start = { _.start },  // Called when sesion.start is called
    shutdown = { _.stop } // Called when session.shutdown is called
  )
}
```

You can also use onInit/onStart/onShutdown methods:
```
bind[X]
  .onInit { x => ... }
  .onStart { x => ... }
  .onShutdown { x => ... }
```

## Debugging Airframe Binding and Injection

To check the runtime behaviour of Airframe object injection, set the log level of `wvlet.airframe`
to `debug` or `trace`:

**src/main/resources/log.properties**
```
wvlet.airframe=debug
```

While debugging the code in your test cases, you can also use `log-test.properties` file:
**src/test/resources/log-test.properties**
```
wvlet.airframe=debug
```
See [wvlet-log configuration](https://github.com/wvlet/log#configuring-log-levels) for the details of log level configurations.


Then you will see the log messages that show the object bindings and injection activities:
```
2016-12-29 22:23:17-0800 debug [Design] Add binding: ProviderBinding(DependencyFactory(PlaneType,List(),wvlet.airframe.LazyF0@442b0f),true,true)  - (Design.scala:43)
2016-12-29 22:23:17-0800 debug [Design] Add binding: ProviderBinding(DependencyFactory(Metric,List(),wvlet.airframe.LazyF0@1595a8db),true,true)  - (Design.scala:43)
2016-12-29 22:23:17-0800 debug [Design] Add binding: ClassBinding(Engine,GasolineEngine)  - (Design.scala:43)
2016-12-29 22:23:17-0800 debug [Design] Add binding: ProviderBinding(DependencyFactory(PlaneType,List(),wvlet.airframe.LazyF0@b24c12d8),true,true)  - (Design.scala:43)
2016-12-29 22:23:17-0800 debug [Design] Add binding: ClassBinding(Engine,SolarHybridEngine)  - (Design.scala:43)
2016-12-29 22:23:17-0800 debug [SessionBuilder] Creating a new session: session:7bf38868  - (SessionBuilder.scala:48)
2016-12-29 22:23:17-0800 debug [SessionImpl] [session:7bf38868] Initializing  - (SessionImpl.scala:48)
2016-12-29 22:23:17-0800 debug [SessionImpl] [session:7bf38868] Completed the initialization  - (SessionImpl.scala:55)
2016-12-29 22:23:17-0800 debug [SessionImpl] Get or update dependency [AirPlane]  - (SessionImpl.scala:80)
2016-12-29 22:23:17-0800 debug [SessionImpl] Get dependency [wvlet.obj.tag.@@[example.Example.Wing,example.Example.Left]]  - (SessionImpl.scala:60)
2016-12-29 22:23:17-0800 debug [SessionImpl] Get dependency [wvlet.obj.tag.@@[example.Example.Wing,example.Example.Right]]  - (SessionImpl.scala:60)
2016-12-29 22:23:17-0800 debug [SessionImpl] Get dependency [example.Example.Engine]  - (SessionImpl.scala:60)
2016-12-29 22:23:17-0800 debug [SessionImpl] Get or update dependency [Fuel]  - (SessionImpl.scala:80)
2016-12-29 22:23:17-0800 debug [SessionImpl] Get dependency [example.Example.PlaneType]  - (SessionImpl.scala:60)
2016-12-29 22:23:17-0800 debug [SessionImpl] Get dependency [example.Example.Metric]  - (SessionImpl.scala:60)
```

# More Illustrative Examples

Here is a more illustrative usage example of Airframe.
You can find the whole code used here from [AirframeTest](https://github.com/wvlet/airframe/blob/master/airframe/src/test/scala/wvlet/airframe/AirframeTest.scala).

In this example, we will create a service that prints a greeting at random:

```scala
import wvlet.airframe._
import wvlet.log.LogSupport

trait Printer {
  def print(s: String): Unit
}

// Concrete classes which will be bound to Printer
class ConsolePrinter(config: ConsoleConfig) extends Printer {
  def print(s: String) { println(s) }
}
class LogPrinter extends Printer with LogSupport {
  def print(s: String) { info(s) }
}

class Fortune {
  def generate: String = { /** generate random fortune message **/ }
}
```

## Local variable binding

Using local variables is the simplest way to binding objects:

```scala
trait FortunePrinterEmbedded {
  val printer = bind[Printer]
  val fortune = bind[Fortune]

  printer.print(fortune.generate)
}
```

## Reuse bindings with mixin

To reuse bindings, we can create XXXService traits and mix-in them to build a complex object.

```scala
import wvlet.airframe._

trait PrinterService {
  val printer = bind[Printer] // It can bind any Printer types
}

trait FortuneService {
  val fortune = bind[Fortune]
}

trait FortunePrinterMixin extends PrinterService with FortuneService {
  printer.print(fortune.generate)
}
```

It is also possible to manually inject an instance implementation. This is useful for changing the behavior of objects for testing:
```scala
trait CustomPrinterMixin extends FortunePrinterMixin {
  override val printer = new Printer { def print(s:String) = { Console.err.println(s) } } // Manually inject an instance
}
```

## Type alias binding

Airframe can provide separate implementations to the same type object by using type alias:
```scala
case class Fruit(name: String)

type Apple = Fruit
type Banana = Fruit

trait TaggedBinding {
  val apple  = bind[Apple]
  val banana = bind[Banana]
}
 ```

Alias binding is also useful to inject primitive type values:
```scala
type Env = String

trait MyService {
  // Coditional binding
  lazy val threadManager = bind[Env] match {
     case "test" => bind[TestingThreadManager] // prepare a testing thread manager
     case "production" => bind[ThreadManager] // prepare a thread manager for production
  }
}

val coreDesign = newDesign
val testingDesign = coreDesign.bind[Env].toInstance("test")
val productionDesign = coreDesign.bind[Env].toInstance("production")
```

## Tagged type binding

Taggged binding `@@` is also useful to annotate type names:

```scala
// This import statement is necessary to use tagged type (@@)
import wvlet.surface.tag._

trait Name
trait Id

trait A {
  val name = bind[String @@ Name] 
  val id = bind[Int @@ Id] 
}
```

## Object Injection

Before binding objects, you need to define a `Design` of dependent components. It is similar to `modules` in Guice.

```scala
val design = newDesign
  .bind[Printer].to[ConsolePrinter]  // Airframe will generate an instance of ConsolePrinter by resolving its dependencies
  .bind[ConsoleConfig].toInstance(ConsoleConfig(System.err)) // Binding an actual instance
```

To bind a class to a singleton, use `toSingleton`:

```scala
class HeavyObject extends LogSupport { /** */ }

val design = newDesign
  .bind[HeavyOBject].toSingleton
````

We can create an object from a design by using `newSession.build[X]`:

```
design.newSession.build[FortunePrinterMixin]
```

See more detail in [AirframeTest](https://github.com/wvlet/airframe/blob/master/airframe/src/test/scala/wvlet/airframe/AirframeTest.scala).

# Comparison with the other DI frameworks

There are two types of dependency injection approaches; runtime and compile-time (static) DIs.

## Run-time Dependency Injection

- [Google Guice](https://github.com/google/guice) is a popular run-time dependency injection libraries in Java, which is also used in [Presto](https://github.com/prestodb/presto) to construct a distributed SQL engine consisting of hundreds of classes. Guice itself does not manage the lifecycle of objects and binding configurations, so Presto team at Facebook has developed [airlift-bootstrap](https://github.com/airlift/airlift/tree/master/bootstrap/src/main/java/io/airlift/bootstrap) and [airlift- configuration](https://github.com/airlift/airlift/tree/master/configuration/src/main/java/io/airlift/configuration) libraries to extend Guice's functionality.
   - One of the disadvantages of Guice is it requires constructor annotation like `@Inject`. This is less convenient if you are using third-party libraries, which cannot add such annotations. So you often need to write a provider binding modules to use third-party classes.
   - Airframe has provider bindings in `bind { d1: D1 => new X(d1) }` syntax so that you can directly call the constructor of third-party classes. No need to implement object binding modules.

- [Scaldi](https://github.com/scaldi/scaldi) is an early adaptor of Guice like DI for Scala and has implemented all of the major functionalities of Guice. However it requires extending your class with Scaldi `Module`. Airframe is simplifying it so that you only need to use `bind[X]` without extending any trait.

- [Spring IoC container](https://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html) Spring framework popularized the notion of [Inversion of Control](https://martinfowler.com/articles/injection.html), which is now simply called DI. Spring uses XML based configuration, which is less programmer-friendly, but it has been useful to manage ordering of object initializations outside the program.

- [Weld](http://weld.cdi-spec.org/) is a reference implementation of [Contexts & Dependency Injection for Java (CDP)](http://cdi-spec.org/) specifications for managing object life cycle and DI for Java EE applications. Weld, for example, has HTTP request scoped object life cycle, annotations for describing how to inject dependencies, etc.

## Compile-time Dependency Injection

- [MacWire](https://github.com/adamw/macwire) is a compile-time dependency injection library for Scala using `wire[A]` syntax. MacWire ensures all binding types are available at compile time, so if some dependency is missing, it will be shown as a compile error. That is a major advantage of MacWire. On the other hand it sacrifices dynamic binding; For example, we cannot switch the implementation of `wire[A]` to `class AImpl(d1:D1, d2:D2, d3:D3) extends A`, because we cannot statically resolve dependencies to AImpl, D1, D2, and D3 at compile time.

- [Dagger2](https://github.com/google/dagger) is also a compile-time dependency injection library for Java and Android. Google needed binding hundreds of modules, but Guice only resolves these dependencies at runtime, so binding failures can be found later when the application is running. To resolve this, Dagger2 tries to generate dependency injection code at compile time. [This document](https://google.github.io/dagger/users-guide) is a good read to understand the background of why compile-time DI was necessary.

Both of MacWire and Dagger2 requires all of the dependencies should be found in the same scope. There are pros and cons in this approach; A complex example is [Guardian](https://github.com/guardian/frontend)'s [frontend code](https://github.com/guardian/frontend/blob/06b94f88593e68682fb2a03c6d878947f8472d44/admin/app/controllers/AdminControllers.scala), which lists 30 dependencies, including transitive dependenceis, in a single trait to resolve dependencies at compile time. In runtime DI, we only need to write direct dependencies.

## Summary

- Compile-time dependency injection:
  - [pros] Can validate the presence of dependencies at compile time.
  - [pros] Fast since all binding codes are generated at compile time.
  - [cons] Less flexible (e.g., No dynamic type binding)
  - [cons] Need to enumerate all dependencies in the same scope (lengthy code).

- Run-time dependency injection
  - [pros] Allows dynamic type binding.
  - [pros] Simpler code. Only need to bind direct dependencies.
  - [cons] Missed binding founds as a runtime error

Airframe belongs to a runtime dependency injection library, and resolves several short-comings of Google Guice (lack of lifecycle manager, difficulty of binding third-party objects, etc.). We also have implemented Scala-friendly DI syntax in Airframe. For the performance reason, Airframe uses Scala macros to generate binding code as much as possible (except dynamic type binding, which cannot be found at compile-time). To use Airframe, you don't need to understand the whole concept of DI and features in the existing DI frameworks. Just `bind`-`design`-`build` objects. That is all you need to know!


# LICENSE

[Apache v2](https://github.com/wvlet/airframe/blob/master/LICENSE)
